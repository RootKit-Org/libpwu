.IX Title "MAP 3
.TH MAP 3 "Oct 2024" "liblain v1.0.2" "map"
.\" Automatically generated by Pandoc 3.1.11.1
.\"
.SS LIBRARY
Lain memory manipulation library (liblain, \-llain)
.SS SYNOPSIS
.IP
.EX
//these macros take a cm_list_node pointer
#define LN_GET_NODE_AREA(node)  ((ln_vm_area *) (node\->data))
#define LN_GET_NODE_OBJ(node)   ((ln_vm_obj *) (node\->data))
#define LN_GET_NODE_PTR(node)   *((cm_list_node **) (node\->data))

//ln_vm_area.access bitmasks
#define LN_ACCESS_READ    0x01
#define LN_ACCESS_WRITE   0x02
#define LN_ACCESS_EXEC    0x04
#define LN_ACCESS_SHARED  0x08


struct _ln_vm_obj;

// \-\-\- [memory area]
typedef struct {

    char * pathname;
    char * basename;

    uintptr_t start_addr;
    uintptr_t end_addr;

    cm_byte access;

    cm_list_node * obj_node_ptr;      //STORES: own vm_obj *
    cm_list_node * last_obj_node_ptr; //STORES: last encountered vm_obj *

    int id;
    bool mapped; //can be set to false with map update

} ln_vm_area;


// \-\-\- [\[aq]backing\[aq] object]
struct _ln_vm_obj {

    char pathname[PATH_MAX];
    char basename[NAME_MAX];

    uintptr_t start_addr;
    uintptr_t end_addr;

    cm_list vm_area_node_ptrs; //STORES: cm_list_node * of ln_vm_area

    int id;
    bool mapped; //can be set to false with map update
};
typedef struct _ln_vm_obj ln_vm_obj;


// \-\-\- [memory map]
typedef struct {

    //up to date entries
    cm_list vm_areas;   //STORES: ln_vm_area
    cm_list vm_objs;    //STORES: ln_vm_obj

    //unmapped entries (storage for future deallocation)
    cm_list vm_areas_unmapped; //STORES: cm_list_node * of ln_vm_area
    cm_list vm_objs_unmapped;  //STORES: cm_list_node * of ln_vm_obj

    // [internal]
    int next_id_area;
    int next_id_obj;

} ln_vm_map;


void ln_new_vm_map(ln_vm_map * vm_map);
int ln_del_vm_map(ln_vm_map * vm_map);
int ln_map_clean_unmapped(ln_vm_map * vm_map);

off_t ln_get_area_offset(const cm_list_node * area_node, const uintptr_t addr);
off_t ln_get_obj_offset(const cm_list_node * obj_node, const uintptr_t addr);
cm_list_node * ln_get_vm_area_by_addr(const ln_vm_map * vm_map, 
                                      const uintptr_t addr, const off_t * offset);

cm_list_node * ln_get_vm_obj_by_addr(const ln_vm_map * vm_map, 
                                     const uintptr_t addr, off_t * offset);
cm_list_node * ln_get_vm_obj_by_pathname(const ln_vm_map * vm_map, 
                                         const char * pathname);
cm_list_node * ln_get_vm_obj_by_basename(const ln_vm_map * vm_map, 
                                         const char * basename);
.EE
.SS STRUCTURE
\f[B]liblain\f[R] heavily relies on the linked list implementation
provided by \f[B]libcmore\f[R].
Have a look at \f[B]libcmore_list\f[R](3) to understand their interface.
.PP
A memory map represents the virtual memory area address mappings of a
process.
The memory map of a target is represented by a \f[I]ln_vm_map\f[R]
structure.
This structure consists of 2 main linked lists: \f[I]vm_areas\f[R] and
\f[I]vm_objs\f[R].
The \f[I]vm_areas\f[R] list stores the virtual memory areas of a
process.
The \f[I]vm_objs\f[R] list stores the backing objects of a process.
.PP
The \f[I]ln_vm_area\f[R] structure represents a single virtual memory
area of a process (kernel: struct \f[I]vm_area_struct\f[R]).
Access permissions of an area can be checked by applying the
\f[I]LN_ACCESS_READ\f[R], \f[I]LN_ACCESS_WRITE\f[R],
\f[I]LN_ACCESS_EXEC\f[R], and \f[I]LN_ACCESS_SHARED\f[R] bitmasks to the
\f[I]access\f[R] member.
.PP
The \f[I]ln_vm_obj\f[R] structure represents a single `backing file' of
a set of virtual memory areas (kernel *vm_area_struct.vm_file).
.PP
Traversal between an area and its object can be done in O(1).
Each area stores a pointer to its corresponding object list node,
\f[I]obj_node_ptr\f[R], if one is present.
Each area without a corresponding object stores a pointer to the last
encountered object list node instead, \f[I]last_obj_node_ptr\f[R].
Each object contains a list of pointers to its corresponding area list
nodes, \f[I]vm_area_node_ptrs\f[R].
.PP
The macros \f[I]LN_GET_NODE_AREA()\f[R], \f[I]LN_GET_NODE_OBJ()\f[R],
and \f[I]LN_GET_NODE_PTR()\f[R] have been provided to easily fetch the
data held by a linked list node.
.PP
A memory map is populated and updated by calling
\f[B]ln_update_map()\f[R] on an open session.
See \f[B]liblain_iface\f[R](3).
.PP
Following an update to a map, some areas and objects may become
unmapped.
To prevent pointer invalidation, their list nodes will be moved to the
\f[I]vm_areas_unmapped\f[R] and \f[I]vm_objs_unmapped\f[R] linked lists.
The \f[I]mapped\f[R] values of their \f[I]ln_vm_area\f[R] and
\f[I]ln_vm_obj\f[R] structures will be set to false, and the
\f[I]next\f[R] and \f[I]prev\f[R] pointers of their nodes will be set to
NULL.
When ready, all unmapped nodes can be deallocated with
\f[B]ln_map_clean_unmapped()\f[R].
.SS FUNCTIONS
The \f[B]ln_new_vm_map()\f[R] function initialises a new map
\f[I]vm_map\f[R].
.PP
The \f[B]ln_del_vm_map()\f[R] function deallocates all contents of a map
\f[I]vm_map\f[R].
.PP
The \f[B]ln_map_clean_unmapped()\f[R] function deallocates all unmapped
areas and objects of a map \f[I]vm_map\f[R].
.PP
The \f[B]ln_get_area_offset()\f[R] function returns the offset of
\f[I]addr\f[R] from the start of the area \f[I]area_node\f[R].
.PP
The \f[B]ln_get_obj_offset()\f[R] function returns the offset of
\f[I]addr\f[R] from the start of the obj \f[I]obj_node\f[R].
.PP
The \f[B]ln_get_area_offset_bnd()\f[R] function returns the offset of
\f[I]addr\f[R] from the start of the area \f[I]area_node\f[R], or \-1 if
the address is not in the area.
.PP
The \f[B]ln_get_obj_offset_bnd()\f[R] function returns the offset of
\f[I]addr\f[R] from the start of the obj \f[I]obj_node\f[R], or \-1 if
the address is not in the area.
.PP
The \f[B]ln_get_vm_area_by_addr()\f[R] functions returns a pointer to
the area node that \f[I]addr\f[R] falls into.
If \f[I]offset\f[R] is not NULL, it is set to the offset of
\f[I]addr\f[R] from the beginning of the area.
.PP
The \f[B]ln_get_vm_obj_by_addr()\f[R] function returns a pointer to the
object node that \f[I]addr\f[R] falls into.
If \f[I]offset\f[R] is not NULL, it is set to the offset of
\f[I]addr\f[R] from the beginning of the object.
.PP
The \f[B]ln_get_vm_obj_by_pathname()\f[R] function returns a pointer to
the first object who\[cq]s path matches \f[I]pathname\f[R].
.PP
The \f[B]ln_get_vm_obj_by_basename()\f[R] function returns a pointer to
the first object who\[cq]s name matches \f[I]basename\f[R].
.SS RETURN VALUES
\f[B]ln_new_vm_map()\f[R], \f[B]ln_del_vm_map()\f[R], and
\f[B]ln_map_clean_unmapped()\f[R] functions return 0 on success and \-1
on error.
.PP
\f[B]ln_get_area_offset()\f[R], and \f[B]ln_get_obj_offset()\f[R] return
an offset on success, and \-1 if \f[I]addr\f[R] does not belong in the
area/object.
.PP
\f[B]ln_get_vm_area_by_addr()\f[R] return a \f[I]cm_list_node *\f[R]
holding a \f[I]ln_vm_area\f[R] on success, and NULL on error.
.PP
\f[B]ln_get_vm_obj_by_addr()\f[R],
\f[B]ln_get_vm_obj_by_pathname()\f[R], and
\f[B]ln_get_vm_obj_by_basename()\f[R] return a \f[I]cm_list_node *\f[R]
on success, and NULL on error.
.PP
On error, \f[I]ln_errno\f[R] is set.
See \f[B]liblain_error\f[R](3).
.SS EXAMPLES
See \f[I]src/test/map.c\f[R] for examples.
.SS SEE ALSO
\f[B]liblain_error\f[R](3), \f[B]liblain_iface\f[R](3),
\f[B]liblain_util\f[R](3)
