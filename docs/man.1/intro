.\" generated with Ronn-NG/v0.9.1
.\" http://github.com/apjanke/ronn-ng/tree/0.9.1
.TH "INTRO" "" "May 2023" ""
Thanks for trying out libpwu! This quick introduction will explore some key parts of the library\. In the end we will have a tool that can map out process memory and overwrite executable segments\.
.SH "mapping process memory"
In order to manipulate a process, a good first step is to map out its memory\. The kernel exposes memory maps for every process in the \fB/proc/<pid>/maps\fR special file\. libpwu can read this file into a data structure and organise it into multiple \'views\' to make it easy to work with\.
.P
The following code snippet defines a \fBmaps_data\fR structure used to hold contents of \fB/proc/<pid>/maps\fR\. The data structure is then initialised\. After initialisation, it is passed to \fBread_maps()\fR, the function that does the reading of the maps special file\.
.P
```c int ret; //return integer FILE * fs_maps; //file stream for the /proc/\fIpid\fR/maps special file int fd_mem; //file descriptor for /proc/\fIpid\fR/mem special file maps_data m_data; //maps_data structure, holds all segments
.P
//open \'maps\' and \'mem\' special files ret = open_memory(\fIpid\fR, &fs_maps, &fd_mem); //initialise /proc/\fIpid\fR/maps ret = new_maps_data(&m_data); //read /proc/\fIpid\fR/maps into the m_data structure ret = read_maps(&m_data, &fd_maps); ```
.SH "accessing vectors"
Now that we have mapped out the memory, individual segments can be accessed through the \fBmaps_data\fR structure\. The segments are stored inside a custom vector implementation, represented by the \fBvector\fR structure\. Each segment is represented by a \fBmaps_entry\fR\.
.P
There are two functions for accessing vector elements\. \fBvector_get()\fR retrieves a \fIcopy\fR of the element\. Modifying the copy does not modify the element inside the vector\. \fBvector_get_ref()\fR returns a pointer to the element inside the vector\. Modifying the value at the pointer does modify the vector contents\. Note however that resizing of the vector causes a call to \'realloc()\' which \fIinvalidates all previous pointers to the vector\fR\.
.P
The above is best illustrated with an example\. Let\'s continue our previous example\. We can take the \fBm_data\fR structure and get its fifth segment, then print the start and end address of this segment\.
.P
```c maps_entry * m_entry; //maps_entry structure, holds a single segment
.P
//get a reference to the 5th segment in m_data, using the \'entry_vector\' view ret = vector_get_ref(&m_data\.entry_vector, 4, (byte **) &m_entry); //print the start and end addresses for the 5th segment printf("start addr: %lx, end addr: %lx\en", m_entry\.start_addr, m_entry\.end_addr); ```
.P
The vectors used by libpwu can hold any data type, so the buffers passed to their getter functions should be cast to \fBbyte\fR (char)\.
.SH "changing segment permissions"
If you\'d like to modify the executable segments of a process, you\'ll first have to change the permissions of its executable segment to allow for writing\. Unlike on Windows, on Linux processes may only change the permissions of their own segments\. libpwu allows you to work around this limitation\. The \fBpuppet_attach()\fR function lets you attach to a target process \'tracee\' as a \'tracer\' (man 2 ptrace)\. The target process, now referred to as \'tracee\', can then be made to execute an \'mprotect\' syscall which can modify segment permissions\. If state is restored following this call, the tracee can continue its execution as if nothing happened, with the exception that its executable region is now writeable\. libpwu can automate this process for you with the \fBchange_region_perms()\fR function\.
.P
Lets continue and change the permissions of the segment we acquired in the previous example\.
.P
```c puppet_info p_info; //puppet_info structure p_info\.pid = \fIpid\fR; //manually set the desired process ID
.P
//attach to the target process ret = puppet_attach(p_info); //change the segment permissions to read, write & execute\. ret = change_region_perms(&p\.inf, 7, fd_mem, &m_data, m_entry); ```
.P
NOTE: Unlike POSIX file permissions, memory permissions are inverted\. 1 = read, 2 = write, 4 = exec (man 2 mprotect)\.
.SH "writing memory & exploitation"
libpwu provides a multitude of options for exploiting processes\. The most simple method is uses \fBwrite_mem()\fR to directly write memory\. \fBraw_inject()\fR can be used to inject payloads from the disk\. \fBhook_rj()\fR allows for hooking relative 32bit jumps used extensively by compilers\.
.P
Carrying on our chain of examples, let\'s assume you used a reverse engineering tool like radare2 to find the offset from the 5th segment at which you\'d like to overwrite a \'CMP\' instruction with 3 \'NOP\'s\. Here is how that would look:
.P
```c //a NOP operation is 0x90 in hex\. byte * write_buffer = "\ex90\ex90\ex90";
.P
//write the buffer to the m_entry segment at \fIoffset\fR ret = write_mem(fd_mem, m_entry\->start_addr + \fIoffset\fR, 3); ```
.SH "clean up"
It is important to cleanly deallocate all used structures when they are no longer in use\. Typically, every structure that is initialise with a function prefixed with \'new_\' will need to be deallocated with the corresponding destructor prefixed with \'del_\'\.
.P
For our ongoing example, the clean up section will consist of the following:
.P
\fBc //delete the maps_data structure ret = del_maps_data(&m_data); //detatch from the target process to let it continue execution ret = puppet_detach(p_info);\fR
.SH "other capabilities"
This introduction covered just a small section of libpwu\'s capabilities\. libpwu also provides functions for discovering code caves, pattern matching, trampolining new threads, and more\. Take a look at documentation at \fB\./docs\fR or read the header file at \fB\./libpwu/libpwu\.h\fR for a full list of capabilities\.
.SH "examples"
See example implementations in \fB\./examples\fR
