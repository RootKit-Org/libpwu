.IX Title "INTRO 1
.TH INTRO 1 "May 2023" "libpwu 1.0" "intro"
.\" Automatically generated by Pandoc 3.1.2
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}

.hy
.SH intro
.PP
Thanks for trying out libpwu!
This quick introduction will explore some key parts of the library.
In the end we will have a tool that can map out process memory and
overwrite executable segments.
.SS mapping process memory
.PP
In order to manipulate a process, a good first step is to map out its
memory.
The kernel exposes memory maps for every process in the
\f[V]/proc/<pid>/maps\f[R] special file.
libpwu can read this file into a data structure and organise it into
multiple `views' to make it easy to work with.
.PP
The following code snippet defines a \f[V]maps_data\f[R] structure used
to hold contents of \f[V]/proc/<pid>/maps\f[R].
The data structure is then initialised.
After initialisation, it is passed to \f[V]read_maps()\f[R], the
function that does the reading of the maps special file.
.IP
.nf
\f[C]
int ret;           //return integer
FILE * fs_maps;    //file stream for the /proc/<pid>/maps special file
int fd_mem;        //file descriptor for /proc/<pid>/mem special file
maps_data m_data;  //maps_data structure, holds all segments

//open \[aq]maps\[aq] and \[aq]mem\[aq] special files
ret = open_memory(<pid>, &fs_maps, &fd_mem);
//initialise /proc/<pid>/maps
ret = new_maps_data(&m_data);
//read /proc/<pid>/maps into the m_data structure
ret = read_maps(&m_data, &fd_maps);
\f[R]
.fi
.SS accessing vectors
.PP
Now that we have mapped out the memory, individual segments can be
accessed through the \f[V]maps_data\f[R] structure.
The segments are stored inside a custom vector implementation,
represented by the \f[V]vector\f[R] structure.
Each segment is represented by a \f[V]maps_entry\f[R].
.PP
There are two functions for accessing vector elements.
\f[V]vector_get()\f[R] retrieves a copy of the element.
Modifying the copy does not modify the element inside the vector.
\f[V]vector_get_ref()\f[R] returns a pointer to the element inside the
vector.
Modifying the value at the pointer does modify the vector contents.
Note however that resizing of the vector causes a call to `realloc()'
which invalidates all previous pointers to the vector.
.PP
The above is best illustrated with an example.
Let\[cq]s continue our previous example.
We can take the \f[V]m_data\f[R] structure and get its fifth segment,
then print the start and end address of this segment.
.IP
.nf
\f[C]
maps_entry * m_entry; //maps_entry structure, holds a single segment

//get a reference to the 5th segment in m_data, using the \[aq]entry_vector\[aq] view
ret = vector_get_ref(&m_data.entry_vector, 4, (byte **) &m_entry);
//print the start and end addresses for the 5th segment
printf(\[dq]start addr: %lx, end addr: %lx\[rs]n\[dq], m_entry.start_addr, m_entry.end_addr);
\f[R]
.fi
.PP
The vectors used by libpwu can hold any data type, so the buffers passed
to their getter functions should be cast to \f[V]byte\f[R] (char).
.SS changing segment permissions
.PP
If you\[cq]d like to modify the executable segments of a process,
you\[cq]ll first have to change the permissions of its executable
segment to allow for writing.
Unlike on Windows, on Linux processes may only change the permissions of
their own segments.
libpwu allows you to work around this limitation.
The \f[V]puppet_attach()\f[R] function lets you attach to a target
process `tracee' as a `tracer' (man 2 ptrace).
The target process, now referred to as `tracee', can then be made to
execute an `mprotect' syscall which can modify segment permissions.
If state is restored following this call, the tracee can continue its
execution as if nothing happened, with the exception that its executable
region is now writeable.
libpwu can automate this process for you with the
\f[V]change_region_perms()\f[R] function.
.PP
Lets continue and change the permissions of the segment we acquired in
the previous example.
.IP
.nf
\f[C]
puppet_info p_info; //puppet_info structure
p_info.pid = <pid>; //manually set the desired process ID

//attach to the target process
ret = puppet_attach(p_info);
//change the segment permissions to read, write & execute.
ret = change_region_perms(&p.inf, 7, fd_mem, &m_data, m_entry);
\f[R]
.fi
.PP
NOTE: Unlike POSIX file permissions, memory permissions are inverted.
1 = read, 2 = write, 4 = exec (man 2 mprotect).
.SS writing memory & exploitation
.PP
libpwu provides a multitude of options for exploiting processes.
The most simple method is uses \f[V]write_mem()\f[R] to directly write
memory.
\f[V]raw_inject()\f[R] can be used to inject payloads from the disk.
\f[V]hook_rj()\f[R] allows for hooking relative 32bit jumps used
extensively by compilers.
.PP
Carrying on our chain of examples, let\[cq]s assume you used a reverse
engineering tool like radare2 to find the offset from the 5th segment at
which you\[cq]d like to overwrite a `CMP' instruction with 3
\[cq]NOP\[cq]s.
Here is how that would look:
.IP
.nf
\f[C]
//a NOP operation is 0x90 in hex.
byte * write_buffer = \[dq]\[rs]x90\[rs]x90\[rs]x90\[dq];

//write the buffer to the m_entry segment at <offset>
ret = write_mem(fd_mem, m_entry->start_addr + <offset>, 3);
\f[R]
.fi
.SS clean up
.PP
It is important to cleanly deallocate all used structures when they are
no longer in use.
Typically, every structure that is initialise with a function prefixed
with `new_' will need to be deallocated with the corresponding
destructor prefixed with `del_'.
.PP
For our ongoing example, the clean up section will consist of the
following:
.IP
.nf
\f[C]
//delete the maps_data structure
ret = del_maps_data(&m_data);
//detatch from the target process to let it continue execution
ret = puppet_detach(p_info);
\f[R]
.fi
.SS other capabilities
.PP
This introduction covered just a small section of libpwu\[cq]s
capabilities.
libpwu also provides functions for discovering code caves, pattern
matching, trampolining new threads, and more.
Take a look at documentation at \f[V]./docs\f[R] or read the header file
at \f[V]./libpwu/libpwu.h\f[R] for a full list of capabilities.
.SS examples
.PP
See example implementations in \f[V]./examples\f[R]
