.\" generated with Ronn-NG/v0.9.1
.\" http://github.com/apjanke/ronn-ng/tree/0.9.1
.TH "STRUCTS" "" "May 2023" ""
.SH "vector"
```c typedef struct {
.IP "" 4
.nf
    byte * vector;
    size_t data_size;
    unsigned long length;
.fi
.IP "" 0
.P
} vector; ```
.SS "description"
\fBvector\fR is this library\'s vector implementation\.
.SS "elements"
.IP "\[ci]" 4
\fBvector\fR : pointer to heap allocation holding the vector\.
.IP "\[ci]" 4
\fBdata_size\fR : size of each element\.
.IP "\[ci]" 4
\fBlength\fR : number of elements in the vector\.
.IP "" 0
.SS "functions"
.IP "\[ci]" 4
\fBvector_get()\fR
.IP "\[ci]" 4
\fBvector_get_ref()\fR
.IP "" 0
.P
.br
.SH "maps_entry"
```c typedef struct {
.IP "" 4
.nf
    //read_maps()
    char pathname[PATH_MAX];
    byte perms;
    void * start_addr;
    void * end_addr;

    //get_caves()
    vector cave_vector; //cave
.fi
.IP "" 0
.P
} maps_entry; ```
.SS "description"
\fBmaps_entry\fR represents a single line in a \fB/proc/\e<pid\e>\emaps\fR file for a single process, sorted into the desired components\. Data specific to each segment is also stored here\. Created automatically\.
.SS "elements"
.IP "\[ci]" 4
\fBpathname\fR : name of the backing file for this segment\. refer to \fBproc(5)\fR\.
.IP "\[ci]" 4
\fBperms\fR : permissions for the region in the format taken by \fBmprotect(2)\fR\.
.IP "\[ci]" 4
\fBstart_addr\fR : address of the start of this segment in \fB/proc/\e<pid\e>/mem\fR\.
.IP "\[ci]" 4
\fBend_addr\fR : address of the end of this segment in \fB/proc\e<pid\e>/mem\fR\.
.IP "\[ci]" 4
\fBcave_vector\fR : vector of \fBcave\fR struct\.
.IP "" 0
.SS "functions"
.IP "\[ci]" 4
\fBget_caves()\fR
.IP "" 0
.P
.br
.SH "maps_obj"
```c typedef struct {
.IP "" 4
.nf
    char name[PATH_MAX];
    vector entry_vector; //*maps_entry
.fi
.IP "" 0
.P
} maps_obj; ```
.SS "description"
\fBmaps_obj\fR is a \'backing file\'/pathname based view of \fBmap_entry\fR structures\. It holds the backing file and every segment that belongs to it\. See \fBproc(5)\fR\. Created automatically\.
.SS "elements"
.IP "\[ci]" 4
\fBname\fR : name of the backing file\.
.IP "\[ci]" 4
\fBentry_vector\fR : vector of pointers to \fBmaps_entry\fR structures belonging to this backing file\.
.IP "" 0
.SS "functions"
none\.
.P
.br
.SH "maps_data"
```c typedef struct {
.IP "" 4
.nf
    vector obj_vector; //maps_obj
    vector entry_vector; //maps_entry
.fi
.IP "" 0
.P
} maps_data;
.P
```
.SS "description"
\fBmaps_data\fR is the \fBoverarching\fR data structure representing the entire \fB/proc/\e<pid\e>/maps\fR file for a single process\. Requires initialisation\. Filled by \fBread_maps()\fR\.
.SS "elements"
.IP "\[ci]" 4
\fBobj_vector\fR : vector storing a backing file oriented view of segments\.
.IP "\[ci]" 4
\fBentry_vector\fR : vector storing segments as they appear in \fB/proc/\e<pid\e>/maps\fR\.
.IP "" 0
.SS "functions"
.IP "\[ci]" 4
\fBnew_maps_data()\fR
.IP "\[ci]" 4
\fBdel_maps_data()\fR
.IP "\[ci]" 4
\fBread_maps()\fR
.IP "" 0
.P
.br
.SH "pattern"
```c typedef struct {
.IP "" 4
.nf
maps_entry * search_region;
byte pattern_bytes[PATTERN_LEN];
int pattern_len;
vector offset_vector;
.fi
.IP "" 0
.P
} pattern; ```
.SS "description"
\fBpattern\fR contains members related to performing a byte pattern search on a memory segment\. Requires initialisation\.
.SS "elements"
.IP "\[ci]" 4
\fBsearch_region\fR : segment to carry out the search on\.
.IP "\[ci]" 4
\fBpattern_bytes\fR : pattern of bytes to search for\.
.IP "\[ci]" 4
\fBpattern_len\fR : length of the pattern of bytes to search for\.
.IP "\[ci]" 4
\fBoffset_vector\fR : vector of offsets at which the pattern occurs (first byte)\.
.IP "" 0
.SS "functions"
.IP "\[ci]" 4
\fBnew_pattern()\fR
.IP "\[ci]" 4
\fBdel_pattern()\fR
.IP "\[ci]" 4
\fBmatch_pattern()\fR
.IP "" 0
.P
.br
.SH "cave"
```c typedef struct {
.IP "" 4
.nf
unsigned int offset;
int size;
.fi
.IP "" 0
.P
} cave; ```
.SS "description"
\fBcave\fR stores data about areas of unused memory where payloads may be injected\. Created automatically inside \fBmaps_entry\fR by \fBget_caves()\fR\.
.SS "elements"
.IP "\[ci]" 4
\fBoffset\fR : offset at which the cave begins (first byte)\.
.IP "\[ci]" 4
\fBsize\fR : size of the cave, in bytes\.
.IP "" 0
.SS "functions"
.IP "\[ci]" 4
\fBget_caves()\fR
.IP "" 0
.P
.br
.SH "raw_injection"
```c typedef struct {
.IP "" 4
.nf
maps_entry * target_region;
unsigned int offset;

byte * payload;
unsigned int payload_size;
.fi
.IP "" 0
.P
} raw_injection; ```
.SS "description"
\fBraw_injection\fR stores data for injecting a payload at an arbitrary offset inside a region\. Requires initialisation\.
.SS "elements"
.IP "\[ci]" 4
\fBtarget_region\fR : \fBmaps_entry\fR segment where the injection will take place\.
.IP "\[ci]" 4
\fBoffset\fR : offset at which to begin injection (first byte)\.
.IP "\[ci]" 4
\fBpayload\fR : pointer to heap allocated space holding the payload\.
.IP "\[ci]" 4
\fBpayload_size\fR : size of the payload on the heap in bytes\.
.IP "" 0
.SS "functions"
.IP "\[ci]" 4
\fBnew_raw_injection()\fR
.IP "\[ci]" 4
\fBdel_raw_injection()\fR
.IP "\[ci]" 4
\fBraw_inject()\fR
.IP "" 0
.P
.br
.SH "rel_jump_hook"
```c typedef struct {
.IP "" 4
.nf
maps_entry * from_region;
uint32_t from_offset; //address of jump instruction

maps_entry * to_region;
uint32_t to_offset;
.fi
.IP "" 0
.P
} rel_jump_hook; ```
.SS "description"
\fBrel_jump_hook\fR stores data for hooking an existing 4 byte relative jump and changing the offset to jump to another location\. Set manually\.
.SS "elements"
.IP "\[ci]" 4
\fBfrom_region\fR : \fBmaps_entry\fR segment where the target relative jump is located\.
.IP "\[ci]" 4
\fBfrom_offset\fR : offset at which the relative jump begins (first byte)\.
.IP "\[ci]" 4
\fBto_region\fR : \fBmaps_entry\fR segment where the target relative jump will now jump to\.
.IP "\[ci]" 4
\fBto_offset\fR : offset to which the target relative jump will now jump to inside the \fBto_region\fR segment\.
.IP "" 0
.SS "functions"
.IP "\[ci]" 4
\fBhook_rj()\fR
.IP "" 0
.P
.br
.SH "name_pid"
```c typedef struct {
.IP "" 4
.nf
char name[NAME_MAX];
vector pid_vector; //pid_t
.fi
.IP "" 0
.P
} name_pid;
.P
```
.SS "description"
\fBname_pid\fR stores the name of a target process and a vector of all processes that match this name\. \fBpid_vector\fR is populated by \fBpid_by_name()\fR\. Requires initialisation\.
.SS "elements"
.IP "\[ci]" 4
\fBname\fR : name of the target process
.IP "\[ci]" 4
\fBpid_vector\fR : vector of process IDs that match \fBname\fR\.
.IP "" 0
.SS "functions"
.IP "\[ci]" 4
\fBnew_name_pid()\fR
.IP "\[ci]" 4
\fBdel_name_pid()\fR
.IP "\[ci]" 4
\fBpid_by_name()\fR
.IP "" 0
.P
.br
.SH "puppet_info"
```c typedef struct {
.IP "" 4
.nf
pid_t pid;

struct user_regs_struct saved_state;
struct user_fpregs_struct saved_float_state;

struct user_regs_struct new_state;
struct user_fpregs_struct new_float_state;
.fi
.IP "" 0
.P
} puppet_info;
.P
```
.SS "description"
\fBpuppet_info\fR stores data required to attach to a process and change the permissions of its segments\. Set \fBpid\fR manually, the rest is for internal use\.
.SS "elements"
.IP "\[ci]" 4
\fBpid\fR : target process ID\.
.IP "\[ci]" 4
\fBsaved_state\fR : registers at time of puppet\.
.IP "\[ci]" 4
\fBsaved_float_state\fR : floating point registers at time of puppet\.
.IP "\[ci]" 4
\fBnew_state\fR : registers for \fBmprotect\fR syscall\.
.IP "\[ci]" 4
\fBnew_float_state\fR : floating point registers for \fBmprotect\fR call\.
.IP "" 0
.SS "functions"
.IP "\[ci]" 4
\fBpuppet_attach()\fR
.IP "\[ci]" 4
\fBpuppet_detach()\fR
.IP "\[ci]" 4
\fBpuppet_save_regs()\fR
.IP "\[ci]" 4
\fBpuppet_write_regs()\fR
.IP "\[ci]" 4
\fBchange_region_perms()\fR
.IP "" 0

